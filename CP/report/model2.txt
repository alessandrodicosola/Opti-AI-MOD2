include "globals.mzn";

% Constants
%% Total width
int: W;
set of int: WIDTH = 1..W;
%% Total height
int: H;
set of int: HEIGHT = 1..H;
%% Amount of presents
int: N;
set of int: Presents = 1..N;
%% Array of width of each present
array[Presents] of WIDTH: widths;
%% Array of heights of each present
array[Presents] of HEIGHT: heights;
%% Upper bound for width and height of each present
array[Presents] of 1..W*H: areas = [ widths[i]*heights[i] | i in Presents ];
int: index_max = arg_max(areas);
array[Presents] of 0..W-1: W_UB = [ W - min(widths[i],heights[i])  | i in Presents ];
array[Presents] of 0..H-1: H_UB = [ H - min(widths[i],heights[i]) | i in Presents ];

%% Elements added for using geost_bb
set of int: RECTANGLES = 1..2*N;
set of int: DIMENSIONS = 1..2;
array[1..N*2*2] of int: WIDTH_AND_HEIGHT_INTERLEAVED;

array[RECTANGLES,DIMENSIONS] of int: RECT_SIZE = array2d(RECTANGLES,DIMENSIONS,WIDTH_AND_HEIGHT_INTERLEAVED);
array[RECTANGLES,DIMENSIONS] of int: RECT_OFFSET = array2d(RECTANGLES,DIMENSIONS,[0 | i in 1..4*N ]);
array[int] of set of RECTANGLES:RECT_SHAPE  = [ {i} | i in RECTANGLES ];
array[int] of set of RECTANGLES:VALID_RECT_SHAPE = [ {i*2-1,i*2}  | i in Presents ]; %Otherwise the wrong KIND is used

set of int: SHAPES = 1..length(RECT_SHAPE);


%Decision variable
%% Array of starting position X and Y to be found
array[Presents] of var 0..W-1: X;
array[Presents] of var 0..H-1: Y;

array[Presents,DIMENSIONS] of var int: VARS;
array[Presents] of var SHAPES: KIND;

% Set constant for testing
N = 3;
W = 5;
H = 3;
widths =  [4,4,3];
heights = [2,1,1];
WIDTH_AND_HEIGHT_INTERLEAVED = [4,2,2,4,4,1,1,4,3,1,1,3];
% constraint KIND[1]=1;
% constraint KIND[2]=3;

% Constraints
%% Boundaries 
constraint forall(p in Presents)(X[p] <= W_UB[p] /\ Y[p] <= H_UB[p])::domain;

%% Impose ordering
% constraint lex_lesseq(X,Y);

%% No overlapping between rectangles
constraint forall(p in Presents)(VARS[p,1]=X[p] /\ VARS[p,2]=Y[p]);
constraint geost_bb(2,RECT_SIZE,RECT_OFFSET,RECT_SHAPE,VARS,KIND,[0,0],[W,H]);
constraint forall(p in Presents)(KIND[p] in VALID_RECT_SHAPE[p]);  

%% Implicit constraint
constraint forall(x in 0..W-1 where count(X,x)>0)(sum(p in Presents where X[p] <= x /\ X[p]+RECT_SIZE[KIND[p],1]>x)(RECT_SIZE[KIND[p],2])=H);
constraint cumulative(X,[RECT_SIZE[KIND[p],1] | p in Presents],[RECT_SIZE[KIND[p],2] | p in Presents],H) /\ 
          cumulative(Y,[RECT_SIZE[KIND[p],2] | p in Presents],[RECT_SIZE[KIND[p],1] | p in Presents],W);

solve satisfy;

output ["\(W) \(H)\n","\(N)\n"];
output ["\(widths[i]) \(heights[i]) \(X[i]) \(Y[i]) \(KIND[i])\n" | i in Presents];